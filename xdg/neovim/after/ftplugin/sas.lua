---basic completion for SAS procedure names
local function setup()
	local f = require('f')

	local names = {
		'aceclus',
		'adaptivereg',
		'anova',
		'append',
		'authlib',
		'bchoice',
		'boxplot',
		'calendar',
		'calis',
		'cancorr',
		'candisc',
		'catalog',
		'catmod',
		'causaltrt',
		'cdisc',
		'chart',
		'cimport',
		'cluster',
		'compare',
		'contents',
		'convert',
		'copy',
		'corr',
		'corresp',
		'cport',
		'datasets',
		'datekeys',
		'dbcstab',
		'delete',
		'discrim',
		'display',
		'distance',
		'document',
		'ds2',
		'explode',
		'export',
		'factor',
		'fastclus',
		'fcmp',
		'fedsql',
		'fmm',
		'fontreg',
		'format',
		'forms',
		'freq',
		'fslist',
		'gam',
		'gampl',
		'gee',
		'genmod',
		'glimmix',
		'glm',
		'glmmod',
		'glmpower',
		'glmselect',
		'groovy',
		'hadoop',
		'hdmd',
		'hpcandisc',
		'hpfmm',
		'hpgenselect',
		'hplmixed',
		'hplogistic',
		'hpmixed',
		'hpnlmod',
		'hppls',
		'hpprincomp',
		'hpquantselect',
		'hpreg',
		'hpsplit',
		'http',
		'iclifetest',
		'icphreg',
		'import',
		'inbreed',
		'infomaps',
		'irt',
		'items',
		'javainfo',
		'json',
		'kde',
		'krige2d',
		'lattice',
		'lifereg',
		'lifetest',
		'localedata',
		'loess',
		'logistic',
		'lua',
		'mcmc',
		'mds',
		'means',
		'metadata',
		'metalib',
		'metaoperate',
		'mi',
		'mianalyze',
		'migrate',
		'mixed',
		'modeclus',
		'multtest',
		'nested',
		'nlin',
		'nlmixed',
		'npar1way',
		'odslist',
		'odstable',
		'odstext',
		'options',
		'optload',
		'optsave',
		'orthoreg',
		'pds',
		'pdscopy',
		'phreg',
		'plan',
		'plm',
		'plot',
		'pls',
		'pmenu',
		'power',
		'presenv',
		'princomp',
		'prinqual',
		'print',
		'printto',
		'probit',
		'proto',
		'prtdef',
		'prtexp',
		'psmatch',
		'pwencode',
		'qdevice',
		'quantlife',
		'quantreg',
		'quantselect',
		'rank',
		'reg',
		'registry',
		'release',
		'report',
		'robustreg',
		'rsreg',
		'scaproc',
		'score',
		'seqdesign',
		'seqtest',
		'sgdesign',
		'sgpanel',
		'sgplot',
		'sgrender',
		'sgscatter',
		'sim2d',
		'simnormal',
		'soap',
		'sort',
		'source',
		'spp',
		'sql',
		'sqoop',
		'standard',
		'stdize',
		'stdrate',
		'stepdisc',
		'stream',
		'summary',
		'surveyfreq',
		'surveyimpute',
		'surveylogistic',
		'surveymeans',
		'surveyphreg',
		'surveyreg',
		'surveyselect',
		'tabulate',
		'tapecopy',
		'tapelabel',
		'template',
		'timeplot',
		'tpspline',
		'transpose',
		'transreg',
		'trantab',
		'tree',
		'ttest',
		'univariate',
		'varclus',
		'varcomp',
		'variogram',
		'xsl',
	}

	local proc_regex = vim.regex([[\c\<proc\s\+\k*$]])
	local comp_regex = vim.regex([[\k*$]])

	return function(findstart, base)
		if findstart ~= 0 then
			local current_line   = vim.api.nvim_get_current_line()
			local current_column = vim.api.nvim_win_get_cursor(0)[2]
			local current_text   = current_line:sub(0, current_column)

			if proc_regex:match_str(current_text) then
				return comp_regex:match_str(current_text)
			end

			return -3
		end

		local filter = vim.regex(string.format([[\V\^%s]], base))

		return {
			words = f
				 .iterate(names)
				 :filter(function (x) return filter:match_str(x) ~= nil end)
				 :totable()
		}
	end
end

_G.sas = _G.sas or {}
_G.sas.complete = setup()

vim.bo.comments      = 'sr:/*,mb:/*,ex:*/'
vim.bo.commentstring = '/*%s*/'
vim.bo.omnifunc      = 'v:lua.sas.complete'
