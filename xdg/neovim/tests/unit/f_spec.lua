local f = require('lib.f')

local nil_gen = function () return nil end

describe('functional', function ()
   describe('iterators', function ()
      describe('basic behaviour', function ()
         it('should wrap an iterator triplet into a table', function ()
            local wrapped = f.wrap(nil_gen, true, true)

            assert.same(nil_gen, wrapped.generator)
            assert.same(true,    wrapped.parameter)
            assert.same(true,    wrapped.state)
         end)

         it('should unwrap an iterator metatable into the iterator triplet', function ()
            local ungen, unparameter, unstate = f.unwrap(f.wrap(nil_gen, true, true))

            assert.same(nil_gen, ungen)
            assert.same(true,    unparameter)
            assert.same(true,    unstate)
         end)

         it('should run an iteration when called directly', function ()
            local t = {1, 2, 3, 4}
            local i = f.iterate(t)

            assert.same(1, i())
            assert.same(1, i())
            assert.same(1, i())
            assert.same(1, i())
         end)

         it('should specify that it is an iterator', function ()
            local t = {1, 2, 3, 4}
            local i = f.iterate(t)

            assert.same('<iterator>', tostring(i))
         end)

         it('should be a (somewhat) drop-in replacement for ipairs', function ()
            local t = {1, 2, 3, 4}
            local r = {}

            for _, i in f.iterate(t) do
               r[#r + 1] = i
            end

            assert.same(#t, #r)
            assert.same(t, r)
         end)

         it('should be a (somewhat) drop-in replacement for pairs', function ()
            local t = { first = 1, second = 2, third = 3, fourth = 4 }
            local r = {}

            for _, k, v in f.iterate(t) do
               r[k] = v
            end

            assert.same(t, r)
         end)

         it('should iterate over all elements', function ()
            local t = { first = 1, second = 2, third = 3, fourth = 4 }
            local r = {}

            f.iterate(t):foreach(function (key, value)
               r[key] = value
            end)

            assert.same(t, r)
         end)

         it('should iterate over the values generated by the given generator function', function ()
            local range_gen = function (p, s)
               local stop, step = p[1], p[2]
               s = s + step

               if s > stop then
                  return nil
               end

               return s, s
            end

            local i = 1

            f.iterate(range_gen, {100, 1}, 0):foreach(function (x)
               assert.same(i, x)
               i = i + 1
            end)
         end)

         it('should keep returning nil when iterating an empty string', function ()
            local i = f.iterate('')

            assert.same(nil, i())
            assert.same(nil, i())
            assert.same(nil, i())
            assert.same(nil, i())
         end)
      end)

      describe('construction', function ()
         it('should not generate an iterator over a non iterable object', function ()
            assert.error(function () f.iterate(0) end)
         end)

         it('should generate an iterator over the given string', function ()
            local i = 1
            local t = { 's', 'o', 'm', 'e', 't', 'h', 'i', 'n', 'g' }

            for k, v in f.iterate('something') do
               assert.same(k, i)
               assert.same(v, t[i])

               i = i + 1
            end
         end)

         it('should generate an iterator over the given table', function ()
            local i = 1
            local t = { 1, 2, 3, 4, 5 }

            for _, v in f.iterate(t) do
               assert.same(t[i], i)
               assert.same(t[i], v)

               i = i + 1
            end
         end)

         it('should always return a valid iterator even when given an iterator', function ()
            local t = {1, 2, 3}
            local r = {}

            for _, v in
               f.iterate(f.iterate(f.iterate(t)))
            do
               table.insert(r, v)
            end

            assert.same(t, r)
         end)

         it('should still return a valid iterator even when given an iterator', function ()
            local t = {1, 2, 3}
            local r = {}

            for _, v in
               f.iterate(t):iterate(t):iterate(t)
            do
               table.insert(r, v)
            end

            assert.same(t, r)
         end)

         it('should return a valid iterator when recycling an iterator nevertheless', function ()
            local s = {1, 2, 3}
            local t = {4, 5, 6}
            local r = {}

            f.iterate(s):iterate(t):foreach(function (v)
               table.insert(r, v)
            end)

            assert.same(t, r)
         end)
      end)

      describe('ranging', function ()
         it('should generate a range of numbers', function ()
            local i = 1

            for _, k in f.range(20) do
               assert.same(i, k)
               i = i + 1
            end
         end)

         it('should generate a range of numbers starting from 1', function ()
            local i = 1

            f.range(20):foreach(function (x)
               assert.same(i, x)
               i = i + 1
            end)
         end)

         it('should generate a range of numbers with a specified start', function ()
            local i = 10

            f.range(10, 30):foreach(function (x)
               assert.same(i, x)
               i = i + 1
            end)
         end)

         it('should generate a range of numbers with a specified step', function ()
            local i = 1

            f.range(1, 100, 5):foreach(function (x)
               assert.same(i, x)
               i = i + 5
            end)
         end)

         it('should generate a range of numbers with a decimal step', function ()
            local i = 1

            f.range(1, 1.6, 0.1):foreach(function (x)
               assert.same(i, x)
               i = i + 0.1
            end)
         end)

         it('should generate a range of numbers with a negative step', function ()
            local i = 100

            f.range(1, 100, -5):foreach(function (x)
               assert.same(i, x)
               i = i - 5
            end)
         end)

         it('should keep generating nil when ranging is not possible', function ()
            local i = f.range(0)

            assert.same(nil, i())
            assert.same(nil, i())
            assert.same(nil, i())
            assert.same(nil, i())
         end)

         it('should be somewhat fast', function ()
            local i = 1

            f.range(20):foreach(function (x)
               assert.same(i, x)
               i = i + 1
            end)
         end)
      end)

      describe('infinite generations', function ()
         it('should generate indefinitely', function ()
            f.duplicate(47):take(20):foreach(function (x)
               assert.same(47, x)
            end)
         end)

         it('should still generate indefinitely', function ()
            f.duplicate(1, 2, 3, 4, 5):take(20):foreach(function (a, b, c, d, e)
               assert.same(1, a)
               assert.same(2, b)
               assert.same(3, c)
               assert.same(4, d)
               assert.same(5, e)
            end)
         end)

         it('should only generate zeros', function ()
            f.zeros():take(20):foreach(function (x)
               assert.same(0, x)
            end)
         end)

         it('should only generate ones', function ()
            f.ones():take(20):foreach(function (x)
               assert.same(1, x)
            end)
         end)

         it('should generate an iterator from the given function', function ()
            local round = 0

            f.tabulate(function (x) return 20 * x end):take(20):foreach(function (x)
               assert.same(round, x)
               round = round + 20
            end)
         end)
      end)

      describe('random sampling', function ()
         it('should generate pseudo-random real numbers in the [0,1] interval', function ()
            assert.truthy(f.random():take(20):every(function (x) return x >= 0 and x < 1 end))
            assert.unique(f.random():take(20))
         end)

         it('should raise an error if the interval is empty', function ()
            assert.error(function () f.random(0) end)
         end)

         it('should generate pseudo-random integers in the specified interval', function ()
            assert.truthy(f.random(1024):take(20):every(function (x)
               return math.floor(x) == x
            end))
         end)

         it('should still generate pseudo-random integers lesser than the given bound', function ()
            assert.truthy(f.random(2):take(20):every(function (x)
               return math.floor(x) == x
            end))
         end)

         it('should generate only zeros from the bounded interval', function ()
            assert.truthy(f.random(0, 1):take(20):every(function (x)
               return x == 0
            end))
         end)

         it('should still generate only the lower bound', function ()
            assert.truthy(f.random(1024, 1025):take(20):every(function (x)
               return x == 1024
            end))
         end)

         it('should generate pseudo-random integers in the specified bound', function ()
            assert.truthy(f.random(1024, 2048):take(20):every(function (x)
               return x >= 1024 and x < 2048
            end))

            assert.unique(f.random(1024, 2048):take(20))
         end)
      end)

      describe('slicing', function ()
         describe('with nth', function ()
            it('should return the value from the n-th iteration', function ()
               -- assert.same(3, f.nth(3, f.range(5)))
               assert.same(3, f.range(5):nth(3))
            end)

            it('should return nil when the iterator is fully consumed', function ()
               assert.same(nil, f.range(5):nth(6))
            end)

            it('should return the n-th element when given a table', function ()
               assert.same('c', f.nth(3, {'a', 'b', 'c', 'd'}))
            end)

            it('should return the n-th character when given a string', function ()
               assert.same('c', f.nth(3, 'abcd'))
            end)

            it('should return nil when the given string is exceeded', function ()
               assert.same(nil, f.nth(5, f.iterate('abcd')))
            end)

            it('should return nil when generating nil', function ()
               assert.same(nil, f.nth(5, f.iterate(nil_gen, nil, nil)))
            end)
         end)

         describe('with tail/head', function ()
            it('should always the iterator without its first element', function ()
               local r = f.iterate({ 'first', 'second', 'third', 'fourth' })

               assert.same('second', r:tail():head())
               assert.same('second', r:tail():head())
            end)

            it('should always return nil', function ()
               f.iterate(''):tail():foreach(function (x) assert.same(nil, x) end)
            end)
         end)
      end)

      describe('subsequences', function ()
         describe('using take', function ()
            it('should return an iterator on the subsequence of first n elements', function ()
               f.duplicate(47):take_n(20):foreach(function (x)
                  assert.same(47, x)
               end)
            end)

            it('should return nil when iterator is exhausted', function ()
               f.iterate('a'):tail():take_n(20):foreach(function (x) assert.same(nil, x) end)
            end)

            it('should keep iterating while the predicate is valid', function ()
               local i = 1

               f.range(10):take_while(function (x) return x < 5 end):foreach(function (x)
                  assert.same(i, x)
                  i = i + 1
               end)
            end)

            it('should detect when given a predicate and keep iterating while it is valid', function ()
               local i = 1

               f.range(10):take(function (x) return x < 5 end):foreach(function (x)
                  assert.same(i, x)
                  i = i + 1
               end)

               assert.same(5, i)
            end)
         end)

         describe('using drop', function ()
            it('should return an iterator after skipping the first n elements', function ()
               local i = 6

               f.range(10):drop_n(5):foreach(function (x)
                  assert.same(i, x)
                  i = i + 1
               end)

               assert.same(11, i)
            end)

            it('should return nil when iterator is exhausted', function ()
               f.iterate('a'):drop_n(2):foreach(function (x) assert.same(nil, x) end)
            end)

            it('should keep skipping while the iterator is valid', function ()
               local i = 5

               f.range(10):drop_while(function (x) return x < 5 end):foreach(function (x)
                  assert.same(i, x)
                  i = i + 1
               end)

               assert.same(i, 11)
            end)

            it('should return nil when the iterator is exhausted', function ()
               f.iterate('a'):drop_while(function (x) return x == 'a' end):foreach(function (x) assert.same(nil, x) end)
            end)

            it('should detect when given a number of elements to skip', function ()
               local i = 6

               f.range(10):drop(5):foreach(function (x)
                  assert.same(i, x)
                  i = i + 1
               end)

               assert.same(11, i)
            end)

            it('should detect when given a predicate and keep skipping while it is valid', function ()
               local i = 5

               f.range(10):drop(function (x) return x < 5 end):foreach(function (x)
                  assert.same(i, x)
                  i = i + 1
               end)

               assert.same(11, i)
            end)
         end)

         describe('using split', function ()
            it('should split the iterator into two with the given predicate', function ()
               local i = 1

               f.zip(f.range(10):split_p(function (x) return x < 5 end)):foreach(function (x, y)
                  assert.same(i,     x)
                  assert.same(i + 4, y)
                  i = i + 1
               end)

               assert.same(5, i)
            end)

            it('should split the iterator into two given a number of elements', function ()
               local i = 1

               f.zip(f.range(10):split_p(5)):foreach(function (x, y)
                  assert.same(i,     x)
                  assert.same(i + 5, y)
                  i = i + 1
               end)

               assert.same(6, i)
            end)

            it('should split the string given a separator', function ()
               local i = 0

               f.split('ab,ab,ab', ','):foreach(function (x)
                  assert.same('ab', x)
                  i = i + 1
               end)

               assert.same(3, i)
            end)

            it('should split the string given a separator', function ()
               local i = 0

               f.iterate('ab,ab,ab'):split(','):foreach(function (x)
                  assert.same('ab', x)
                  i = i + 1
               end)

               assert.same(3, i)
            end)

            it('should split the string given a separator after skipping', function ()
               local i = 0

               f.iterate('ab,ab,ab'):drop(4):split(','):foreach(function (x)
                  assert.same('ab', x)
                  i = i + 1
               end)

               assert.same(2, i)
            end)

            it('should split the string into words', function ()
               local i = 0

               f.iterate('abc abc abc'):words():foreach(function (x)
                  assert.same('abc', x)
                  i = i + 1
               end)

               assert.same(3, i)
            end)

            it('should split the string into lines', function ()
               local i = 0

               f.iterate([[abc
                  abc
                  abc]])
                :lines()
                :foreach(function (x)
                  assert.same('abc', x:gsub(' ', ''))
                  i = i + 1
               end)

               assert.same(3, i)
            end)
         end)
      end)

      describe('indexing', function ()
         it('should return the first element of the index that matches', function ()
            assert.same(2, f.range(5):index(2))
         end)

         it('should return nil when no element matches', function ()
            assert.same(nil, f.range(5):index(6))
         end)

         it('should return a table with all the indices of the elements that match', function ()
            local i = 1
            local t = {1, 4, 6, 8, 11}

            f.iterate('abracadabra'):indexes('a'):foreach(function (x)
               assert.same(t[i], x)
               i = i + 1
            end)

            assert.same(6, i)
         end)
      end)

      describe('filtering', function ()
         describe('using filter', function ()
            it('should filter the elements that don\'t satisfy the given predicate', function ()
               local i = 3

               f.range(10):filter(function (x) return x % 3 == 0 end):foreach(function (x)
                  assert.same(i, x)
                  i = i + 3
               end)

               assert.same(12, i)
            end)

            it('should not iterate at all when the iterator is empty', function ()
               local i = 0

               f.filter(function (_) i = i + 1 return true end, f.range(0))

               assert.same(0, i)
            end)

            it('should even filter zipped iterators', function ()
               local i = 1

               local t = {
                  {0,  0,  0},
                  {16, 48, 32},
               }

               f.zip(
                  f.range(0, 50, 1),
                  f.range(0, 50, 2),
                  f.range(0, 50, 3)
               )
                  :map(function (a, b, c)
                     return a, c, b
                  end)
                  :filter(function (a, _, _)
                     if a % 16 == 0 then
                        return true
                     else
                        return false
                     end
                  end)
                  :foreach(function (a, b, c)
                     assert.same(t[i], {a, b, c})
                     i = i + 1
                  end)

               assert.same(3, i)
            end)

            it('should return nil when there is nothing to iterate over', function ()
               local multi_nil_gen = function () return nil, nil end
               local i = 0

               f.filter(function () return true end, multi_nil_gen, nil, nil)
                  :take(5):foreach(function () i = i + 1 end)

               assert.same(0, i)
            end)
         end)

         describe('using grep', function ()
            it('should filter correctly using a string', function ()
               local lines = {
                  'Lorem ipsum dolor sit amet, consectetur adipisicing elit, ',
                  'sed do eiusmod tempor incididunt ut labore et dolore magna ',
                  'aliqua. Ut enim ad minim veniam, quis nostrud exercitation ',
                  'ullamco laboris nisi ut aliquip ex ea commodo consequat.',
                  'Duis aute irure dolor in reprehenderit in voluptate velit ',
                  'esse cillum dolore eu fugiat nulla pariatur. Excepteur sint ',
                  'occaecat cupidatat non proident, sunt in culpa qui officia ',
                  'deserunt mollit anim id est laborum.',
               }

               local expected = {
                  'sed do eiusmod tempor incididunt ut labore et dolore magna ',
                  'ullamco laboris nisi ut aliquip ex ea commodo consequat.',
                  'deserunt mollit anim id est laborum.',
               }

               local i = 1

               f.iterate(lines)
                  :grep('lab')
                  :foreach(function (x)
                     assert.same(expected[i], x)
                     i = i + 1
                  end)

               assert.same(4, i)
            end)

            it('should filter correctly using a regular expression', function ()
               local lines = {
                  'Emily',     'Chloe',
                  'Megan',     'Jessica',
                  'Emma',      'Sarah',
                  'Elizabeth', 'Sophie',
                  'Olivia',    'Lauren',
               }

               local expected = {
                  'Emily', 'Emma'
               }

               local i = 1

               f.iterate(lines)
                  :grep('^Em')
                  :foreach(function (x)
                     assert.same(expected[i], x)
                     i = i + 1
                  end)

               assert.same(3, i)
            end)
         end)

         describe('using partition', function ()
            it('should split the iterator depending on the given predicate', function ()
               local expected = {
                  {3, 1},
                  {6, 2},
                  {9, 4},
               }

               local i = 1

               f.zip(
                  f.range(10):partition(function (x, _) return x % 3 == 0 end)
               )
               :foreach(function (x, y)
                  assert.same(expected[i], {x, y})
                  i = i + 1
               end)

               assert.same(4, i)
            end)
         end)
      end)

      describe('reducing', function ()
         describe('using reduce', function ()
            it('should accumulate the iterator', function ()
               assert.same(15, f.reduce(function (acc, x) return acc + x end, 0,f.range(5)))
               assert.same(15, f.range(5):reduce(function (acc, x) return acc + x end, 0))
            end)

            it('should accumulate the iterator using predefined operators', function ()
               assert.same(15, f.reduce(f.operator.add, 0, f.range(5)))
               assert.same(15, f.range(5):reduce(f.operator.add, 0))
            end)
         end)

         describe('using length', function ()
            it('should return the correct length of the table', function ()
               assert.same(5, f.length({'a', 'b', 'c', 'd', 'e'}))
            end)

            it('should return the correct length of the string', function ()
               assert.same(5, f.length('abcde'))
            end)

            it('should return 0 when the table is empty', function ()
               assert.same(0, f.iterate({}):length())
            end)

            it('should return 0 when the iterator is empty', function ()
               assert.same(0, f.length(f.range(0)))
            end)
         end)

         describe('using is_null', function ()
            it('should be false when the iterator is not exhausted', function ()
               assert.same(false, f.iterate({'a', 'b', 'c'}):is_null())
            end)

            it('should be true when the iterator is not exhausted', function ()
               assert.same(true, f.iterate({}):is_null())
            end)
         end)

         describe('using is_prefix_of', function ()
            it('should be true when the first table is a prefix of the second', function ()
               assert.same(true, f.is_prefix_of({'a'}, {'a', 'b', 'c'}))
            end)

            it('should be true when the first table is empty', function ()
               assert.same(true, f.is_prefix_of({}, {'a', 'b', 'c'}))
            end)

            it('should be false when the first table is not a prefix of the second', function ()
               assert.same(false, f.is_prefix_of({'a'}, {}))
            end)

            it('should be true when the first iterator is a prefix of the second', function ()
               assert.same(true, f.is_prefix_of(f.range(5), f.range(6)))
            end)

            it('should be false when the first iterator is not a prefix of the second', function ()
               assert.same(false, f.range(6):is_prefix_of(f.range(5)))
            end)
         end)

         describe('using every', function ()
            it('should be true if the predicate is satisfied for every element', function ()
               assert.same(true, f.iterate({true, true, true, true}):every(function (x) return x end))
            end)

            it('should be false if the predicate is not satisfied for every element', function ()
               assert.same(false, f.iterate({true, true, true, false}):every(function (x) return x end))
            end)
         end)

         describe('using any', function ()
            it('should be true if the predicate is satisfied for one of the elements', function ()
               assert.same(true, f.iterate({true, false, false, false}):any(function (x) return x end))
            end)

            it('should be false if the predicate is not satisfied for all elements', function ()
               assert.same(false, f.iterate({false, false, false, false}):any(function (x) return x end))
            end)
         end)

         describe('using sum', function ()
            it('should sum all the elements', function ()
               assert.same(15, f.range(1, 5):sum())
            end)

            it('should sum all the elements even if floating', function ()
               assert.same(27, f.range(1, 5, 0.5):sum())
            end)

            it('should return 0 when the iterator is empty', function ()
               assert.same(0, f.sum(f.range(0)))
            end)
         end)

         describe('using product', function ()
            it('should product all the elements', function ()
               assert.same(120, f.range(1, 5):product())
            end)

            it('should product all the elements even if floating', function ()
               assert.same(7087.5, f.range(1, 5, 0.5):product())
            end)

            it('should return 0 when the iterator is empty', function ()
               assert.same(1, f.product(f.range(0)))
            end)
         end)

         describe('using minimum', function ()
            it('should return the smallest number', function ()
               assert.same(1, f.range(10):minimum())
            end)

            it('should return the smallest letter', function ()
               assert.same('d', f.iterate({'z', 'x', 'd'}):minimum())
            end)

            it('should throw an error when the iterator is empty', function ()
               assert.error(function ()
                  f.minimum({})
               end)
            end)
         end)

         describe('using maximum', function ()
            it('should return the biggest number', function ()
               assert.same(10, f.range(10):maximum())
            end)

            it('should return the biggest letter', function ()
               assert.same('z', f.iterate({'z', 'x', 'd'}):maximum())
            end)

            it('should throw an error when the iterator is empty', function ()
               assert.error(function ()
                  f.maximum({})
               end)
            end)
         end)

         describe('using minimum_by', function ()
            local function p (a, b) if -a < -b then return a else return b end end

            it('should return the smallest number given a predicate', function ()
               assert.same(10, f.range(10):minimum_by(p))
            end)

            it('should throw an error when the iterator is empty', function ()
               assert.error(function ()
                  f.minimum_by(p, {})
               end)
            end)
         end)

         describe('using maximum_by', function ()
            local function p (a, b) if -a < -b then return a else return b end end

            it('should return the biggest number given a predicate', function ()
               assert.same(10, f.range(10):maximum_by(p))
            end)

            it('should throw an error when the iterator is empty', function ()
               assert.error(function ()
                  f.maximum_by(p, {})
               end)
            end)
         end)

         describe('using totable', function ()
            it('should return a table from the iterator', function ()
               local expected = {1, 2, 3, 4, 5}

               assert.same(expected, f.range(5):totable())
            end)
         end)

         describe('using tomap', function ()
            it('should return an iterator from the zipped iterators', function ()
               local expected = {'a', 'b', 'c', 'd', 'e', 'f'}
               local i = 1

               local actual = f.zip(
                     f.range(7),
                     'abcdef'
                  ):tomap()

               f.iterate(actual):foreach(function (x)
                  assert.same(expected[i], x)
                  i = i + 1
               end)

               assert.same(7, i)
            end)
         end)
      end)

      describe('transforming', function ()
         describe('using map', function ()
            local fn = function (...) return 'map', ... end

            it('should not iterate when the iterator is empty', function ()
               local i = 0
               f.map(fn, f.range(0)):foreach(function () i = i + 1 end)

               assert.same(0, i)
            end)

            it('should iterate over the given range of numbers', function ()
               local i = 1

               f.range(4):map(fn):foreach(function (x, y)
                  assert.same('map', x)
                  assert.same(i, y)

                  i = i + 1
               end)

               assert.same(5, i)
            end)

            it('should enumerate the given range of letters', function ()
               local expected = {
                  { 'map', 1, 'a' },
                  { 'map', 2, 'b' },
                  { 'map', 3, 'c' },
                  { 'map', 4, 'd' },
                  { 'map', 5, 'e' },
               }

               local i = 1

               f.enumerate('abcde'):map(fn):foreach(function (x, y, z)
                  assert.same(expected[i], {x, y, z})
                  i = i + 1
               end)

               assert.same(6, i)
            end)
         end)

         describe('using enumerate', function ()
            it('should enumerate over the given table', function ()
               local expected = {
                  { 1, 'a' },
                  { 2, 'b' },
                  { 3, 'c' },
                  { 4, 'd' },
                  { 5, 'e' },
               }

               local i = 1

               f.enumerate({'a', 'b', 'c', 'd', 'e'}):foreach(function (x, y)
                  assert.same(expected[i], { x, y })
                  i = i + 1
               end)

               assert.same(6, i)
            end)

            it('should enumerate multiple times', function ()
               local expected = {
                  { 1, 1, 1, 'a' },
                  { 2, 2, 2, 'b' },
                  { 3, 3, 3, 'c' },
                  { 4, 4, 4, 'd' },
                  { 5, 5, 5, 'e' },
               }

               local i = 1

               f.enumerate({'a', 'b', 'c', 'd', 'e'})
                  :enumerate()
                  :enumerate()
                  :foreach(function (w, x, y, z)
                     assert.same(expected[i], { w, x, y, z })
                     i = i + 1
                  end)

               assert.same(6, i)
            end)

            it('should enumerate over zipped iterators', function ()
               local expected = {
                  {1, 'one',   'a'},
                  {2, 'two',   'b'},
                  {3, 'three', 'c'},
                  {4, 'four',  'd'},
                  {5, 'five',  'e'},
               }

               local i = 1

               f.zip(
                  {'one', 'two', 'three', 'four', 'five'},
                  {'a',   'b',   'c',     'd',    'e'}
               )
                  :enumerate()
                  :foreach(function (x, y, z)
                     assert.same(expected[i], { x, y, z })
                     i = i + 1
                  end)

               assert.same(6, i)
            end)
         end)

         describe('using intersperse', function ()
            it('should intersperse the first argument into the iterator', function ()
               local expected = {
                  'a', 'x',
                  'b', 'x',
                  'c', 'x',
                  'd', 'x',
                  'e', 'x',
                  'f', 'x',
               }

               local i = 1

               f.iterate('abcdef'):intersperse('x'):foreach(function (x)
                  assert.same(expected[i], x)
                  i = i + 1
               end)

               assert.same(13, i)
            end)
         end)
      end)

      describe('compositions', function ()
         describe('using zip', function ()
            it('should zip the iterators together', function ()
               local expected = {
                  { 'a', 'one', },
                  { 'b', 'two', },
                  { 'c', 'three', },
               }

               local i = 1

               f.iterate({'a', 'b', 'c', 'd'}):zip({'one', 'two', 'three'}):foreach(function (x, y)
                  assert.same(expected[i], { x, y })
                  i = i + 1
               end)

               assert.same(4, i)
            end)

            it('should not iterate when there is nothing to zip', function ()
               local i = 0

               f.zip():foreach(function () i = i + 1 end)

               assert.same(0, i)
            end)

            it('should zip multiple iterators together', function ()
               assert.same({28, 46, 64, 82}, {
                  f.zip(
                     f.range(1, 100, 3),
                     f.range(1, 100, 5),
                     f.range(1, 100, 7),
                     f.range(1, 100, 9)
                  )
                     :nth(10)
               })
            end)

            it('should zip partitions', function ()
               local expected = {
                  {8,  1},
                  {9,  2},
                  {10, 3},
                  {11, 4},
                  {12, 5},
                  {13, 6},
                  {14, 7},
               }

               local i = 1

               f.zip(f.range(15):partition(function (x) return x > 7 end)):foreach(function (x, y)
                  assert.same(expected[i], { x, y })
                  i = i + 1
               end)

               assert.same(8, i)
            end)
         end)

         describe('using cycle', function ()
            it('should iterate until the end and cycle to the beginning', function ()
               local expected = {'a', 'b', 'c', 'd', 'e'}
               local i = 0

               f.cycle({'a', 'b', 'c', 'd', 'e'}):take(15):foreach(function (x)
                  assert.same(expected[i % 5 + 1], x)
                  i = i + 1
               end)

               assert.same(15, i)
            end)

            it('should cycle over a range of numbers', function ()
               local i = 0

               f.range(5):cycle():take(15):foreach(function (x)
                  assert.same(i % 5 + 1, x)
                  i = i + 1
               end)

               assert.same(15, i)
            end)

            it('should cycle over a zipped iterator', function ()
               local expected = {
                  { 1, 'a' },
                  { 2, 'b' },
                  { 3, 'c' },
                  { 4, 'd' },
                  { 5, 'e' },
               }

               local i = 0

               f.zip(
                  f.range(5),
                  {'a', 'b', 'c', 'd', 'e'}
               )
                  :cycle()
                  :take(15)
                  :foreach(function (x, y)
                     assert.same(expected[i % 5 + 1], { x, y })
                     i = i + 1
                  end)

               assert.same(15, i)
            end)
         end)

         describe('using chain', function ()
            it('should return the same iterator if only one is given', function ()
               local i = 1

               f.range(2):chain():foreach(function (x)
                  assert.same(i, x)
                  i = i + 1
               end)

               assert.same(3, i)
            end)

            it('should chain given iterators', function ()
               local expected = { 1, 2, 'a', 'b', 'c', 'one', 'two', 'three' }
               local i = 1

               f.chain(
                  f.range(2),
                  {'a', 'b', 'c'},
                  {'one', 'two', 'three'}
               )
               :foreach(function (x)
                  assert.same(expected[i], x)
                  i = i + 1
               end)

               assert.same(9, i)
            end)

            it('should chain, cycle, and enumerate correctly', function ()
               local expected = {
                  { 1, 'a' },
                  { 2, 'b' },
                  { 3, 'c' },
                  'one',
                  'two',
                  'three',
               }

               local i = 0

               f.chain(
                  f.enumerate({'a', 'b', 'c'}),
                  {'one', 'two', 'three'}
               )
               :cycle()
               :take(15)
               :foreach(function (x, y)
                  if y == nil then
                     assert.same(expected[i % 6 + 1], x)
                  else
                     assert.same(expected[i % 6 + 1], {x, y})
                  end

                  i = i + 1
               end)

               assert.same(15, i)
            end)

            it('should return the nil generator when no iterators are given', function ()
               local i = 0

               f.chain():foreach(function() i = i + 1 end)

               assert.same(0, i)
            end)
         end)
      end)

      describe('builtin operator', function ()
         describe('comparison', function ()
            it('lt should behave as designed', function ()
               local t = {1, 2, 3, 4}
               local u = {2, 3, 4, 5}

               local result = f.zip(
                  f.iterate(t),
                  f.iterate(u)
               ):every(f.operator.lt)

               assert.is_truthy(result)
            end)

            it('le should behave as designed', function ()
               local t = {1, 2, 3, 4}
               local u = {2, 2, 3, 5}

               local result = f.zip(
                  f.iterate(t),
                  f.iterate(u)
               ):every(f.operator.le)

               assert.is_truthy(result)
            end)

            it('eq should behave as designed', function ()
               local t = {1, 2, 3, 4}

               local result = f.zip(
                  f.iterate(t),
                  f.iterate(t)
               ):every(f.operator.eq)

               assert.is_truthy(result)
            end)

            it('ne should behave as designed', function ()
               local t = {1, 2, 3, 4}
               local u = {2, 3, 4, 5}

               local result = f.zip(
                  f.iterate(t),
                  f.iterate(u)
               ):every(f.operator.ne)

               assert.is_truthy(result)
            end)

            it('gt should behave as designed', function ()
               local t = {2, 3, 4, 5}
               local u = {1, 2, 3, 4}

               local result = f.zip(
                  f.iterate(t),
                  f.iterate(u)
               ):every(f.operator.gt)

               assert.is_truthy(result)
            end)

            it('ge should behave as designed', function ()
               local t = {2, 3, 4, 5}
               local u = {2, 2, 3, 5}

               local result = f.zip(
                  f.iterate(t),
                  f.iterate(u)
               ):every(f.operator.ge)

               assert.is_truthy(result)
            end)

            it('ge should behave as designed', function ()
               local t = {2, 3, 4, 5}
               local u = {2, 2, 3, 5}

               local result = f.zip(
                  f.iterate(t),
                  f.iterate(u)
               ):every(f.operator.ge)

               assert.is_truthy(result)
            end)
         end)

         describe('arithmetic', function ()
            it('add should behave as designed', function ()
               local t = {1, 1, 1, 1}
               local u = {1, 2, 3, 4}
               local v = {2, 3, 4, 5}

               local result = f.zip(
                  f.iterate(t),
                  f.iterate(u)
               )
               :map(f.operator.add)
               :totable()

               assert.same(v, result)
            end)

            it('sub should behave as designed', function ()
               local t = {1, 2, 3, 4}
               local u = {1, 1, 1, 1}
               local v = {0, 1, 2, 3}

               local result = f.zip(
                  f.iterate(t),
                  f.iterate(u)
               )
               :map(f.operator.sub)
               :totable()

               assert.same(v, result)
            end)

            it('div should behave as designed', function ()
               local t = {1,   4, 3, 5}
               local u = {2,   2, 1, 2}
               local v = {0.5, 2, 3, 2.5}

               local result = f.zip(
                  f.iterate(t),
                  f.iterate(u)
               )
               :map(f.operator.div)
               :totable()

               assert.same(v, result)
            end)

            it('mod should behave as designed', function ()
               local t = {1, 4, 3, 5}
               local u = {2, 2, 1, 2}
               local v = {1, 0, 0, 1}

               local result = f.zip(
                  f.iterate(t),
                  f.iterate(u)
               )
               :map(f.operator.mod)
               :totable()

               assert.same(v, result)
            end)

            it('mul should behave as designed', function ()
               local t = {1, 4, 3, 5}
               local u = {2, 2, 1, 2}
               local v = {2, 8, 3, 10}

               local result = f.zip(
                  f.iterate(t),
                  f.iterate(u)
               )
               :map(f.operator.mul)
               :totable()

               assert.same(v, result)
            end)

            it('pow should behave as designed', function ()
               local t = {1, 4,  3, 5}
               local u = {2, 2,  1, 2}
               local v = {1, 16, 3, 25}

               local result = f.zip(
                  f.iterate(t),
                  f.iterate(u)
               )
               :map(f.operator.pow)
               :totable()

               assert.same(v, result)
            end)

            it('neg should behave as designed', function ()
               local t = {1,  4,  3,  5}
               local u = {-1, -4, -3, -5}

               local result = f.iterate(t)
                  :map(f.operator.neg)
                  :totable()

               assert.same(u, result)
            end)

            it('floordiv should behave as designed', function ()
               local t = {1, 4, 3, 5}
               local u = {2, 2, 1, 2}
               local v = {0, 2, 3, 2}

               local result = f.zip(
                  f.iterate(t),
                  f.iterate(u)
               )
               :map(f.operator.floordiv)
               :totable()

               assert.same(v, result)
            end)

            it('intdiv should behave as designed', function ()
               local t = {-1, -4, 3, -5}
               local u = {2,  3,  2, 2}
               local v = {0,  -1, 1, -2}

               local result = f.zip(
                  f.iterate(t),
                  f.iterate(u)
               )
               :map(f.operator.intdiv)
               :totable()

               assert.same(v, result)
            end)
         end)

         describe('string', function ()
            it('concat should concatenate strings', function ()
               local t = {'foo',    'hello'}
               local u = {'bar',    ' world'}
               local v = {'foobar', 'hello world'}

               local result = f.zip(
                  f.iterate(t),
                  f.iterate(u)
               )
               :map(f.operator.concat)
               :totable()

               assert.same(v, result)
            end)

            it('length should concatenate strings', function ()
               local t = {'foo',    'hello'}
               local u = {3, 5}

               local result = f.iterate(t)
                  :map(f.operator.length)
                  :totable()

               assert.same(u, result)
            end)
         end)

         describe('logical', function ()
            it('and (land) should concatenate strings', function ()
               local t = { false, false, true,  true }
               local u = { false, true,  false, true }
               local v = { false, false, false, true }

               local result = f.zip(
                  f.iterate(t),
                  f.iterate(u)
               )
               :map(f.operator.land)
               :totable()

               assert.same(v, result)
            end)

            it('or (lor) should concatenate strings', function ()
               local t = { false, false, true,  true }
               local u = { false, true,  false, true }
               local v = { false, true,  true,  true }

               local result = f.zip(
                  f.iterate(t),
                  f.iterate(u)
               )
               :map(f.operator.lor)
               :totable()

               assert.same(v, result)
            end)

            it('not (lnot) should concatenate strings', function ()
               local t = { false, true }
               local u = { true,  false }

               local result = f.iterate(t)
                  :map(f.operator.lnot)
                  :totable()

               assert.same(u, result)
            end)

            it('truth should concatenate strings', function ()
               local t = { false, true, 'foo', 123 }
               local u = { false, true, true,  true }

               local result = f.iterate(t)
                  :map(f.operator.truth)
                  :totable()

               assert.same(u, result)
            end)
         end)
      end)

      it('should be able to iterate through all elements of a table', function ()
         local t = { first = 1, second = 2, third = 3, fourth = 4 }
         local r = {}

         f.iterate(t):foreach(function (x, y) r[x] = y end)

         assert.same(t, r)
      end)

      it('should be able to iterate through all elements of a table', function ()
         local s = 'something'
         local r = {}

         f.iterate(s):foreach(function (x) table.insert(r, x) end)

         assert.same({'s', 'o', 'm', 'e', 't', 'h', 'i', 'n', 'g'}, r)
      end)

      it('should always return the nth element of the iterator', function ()
         local t = { 'first', 'second', 'third', 'fourth' }
         local r = f.iterate(t)

         assert.same('first',  r:nth(1))
         assert.same('first',  r:nth(1))
         assert.same('second', r:nth(2))
         assert.same('second', r:nth(2))
         assert.same('third',  r:nth(3))
         assert.same('third',  r:nth(3))
         assert.same('fourth', r:nth(4))
         assert.same('fourth', r:nth(4))
      end)

      it('should always return `nil` when the iterator is exceeded', function ()
         local t = { 1, 2, 3, 4 }
         local r = f.iterate(t)

         assert.is_nil(r:nth(5))
         assert.is_nil(r:nth(6))
         assert.is_nil(r:nth(7))
         assert.is_nil(r:nth(8))
         assert.is_nil(r:nth(9))
      end)

      it('should always return the first element of the iterator', function ()
         local t = { 'first', 'second', 'third', 'fourth' }
         local r = f.iterate(t)

         assert.same('first', r:head())
         assert.same('first', r:head())
      end)

      it('should raise an exception when the iterator is empty', function ()
         local r = f.iterate({})

         assert.error(function () r:head() end)
      end)
   end)

   describe('edge case', function ()
      it('deepcopy should throw an error when given a wrong parameter', function ()
         local p = coroutine.create(function () return true end)

         assert.error(function () f.is_null(nil_gen, nil, p) end)
      end)
   end)
end)
